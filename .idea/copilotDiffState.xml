<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/test/java/com/glasswallet/Ledger/service/interfaces/LedgerServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/glasswallet/Ledger/service/interfaces/LedgerServiceTest.java" />
              <option name="originalContent" value="package com.glasswallet.Ledger.service.interfaces;&#10;&#10;import com.glasswallet.Ledger.data.model.LedgerEntry;&#10;import com.glasswallet.Ledger.data.repositories.LedgerRepo;&#10;import com.glasswallet.Ledger.dtos.requests.LogTransactionRequest;&#10;import com.glasswallet.Ledger.enums.LedgerType;&#10;import com.glasswallet.Ledger.enums.Status;&#10;import com.glasswallet.Ledger.service.implementation.LedgerServiceImpl;&#10;import com.glasswallet.Wallet.enums.WalletCurrency;&#10;import com.glasswallet.platform.data.repositories.PlatformUserRepository;&#10;import com.glasswallet.transaction.dtos.request.BulkDisbursementRequest;&#10;import com.glasswallet.transaction.dtos.request.DepositRequest;&#10;import com.glasswallet.transaction.dtos.request.TransferRequest;&#10;import com.glasswallet.transaction.dtos.request.WithdrawalRequest;&#10;import com.glasswallet.user.data.models.User;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class LedgerServiceTest {&#10;&#10;    @Mock private LedgerRepo ledgerRepo;&#10;    @Mock private LedgerOrchestrator ledgerOrchestrator;&#10;    @Mock private PlatformUserRepository userRepository;&#10;&#10;    @InjectMocks private LedgerServiceImpl ledgerService;&#10;&#10;    private DepositRequest depositRequest;&#10;    private WithdrawalRequest withdrawalRequest;&#10;    private TransferRequest transferRequest;&#10;&#10;    @BeforeEach&#10;    void setup() {&#10;        depositRequest = new DepositRequest();&#10;        depositRequest.setAmount(BigDecimal.valueOf(1000));&#10;        depositRequest.setCompanyId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440000&quot;));&#10;        depositRequest.setSenderId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440098&quot;));&#10;        depositRequest.setReceiverId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440789&quot;));&#10;        depositRequest.setCurrency(WalletCurrency.NGN);&#10;        depositRequest.setReference(&quot;ref123&quot;);&#10;&#10;        withdrawalRequest = new WithdrawalRequest();&#10;        withdrawalRequest.setAmount(BigDecimal.valueOf(500));&#10;        withdrawalRequest.setCompanyId(&quot;comp456&quot;);&#10;        User mockUser = new User();&#10;        mockUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440123&quot;));&#10;        withdrawalRequest.setSenderId(String.valueOf(mockUser));&#10;        withdrawalRequest.setSenderId(&quot;sender456&quot;);&#10;        withdrawalRequest.setReceiverId(&quot;receiver456&quot;);&#10;        withdrawalRequest.setCurrency(&quot;USD&quot;);&#10;        withdrawalRequest.setReference(&quot;withdrawRef&quot;);&#10;&#10;        transferRequest = new TransferRequest();&#10;        transferRequest.setAmount(BigDecimal.valueOf(2000));&#10;        transferRequest.setCompanyId(&quot;comp789&quot;);&#10;        User mockTransferUser = new User();&#10;        mockTransferUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440124&quot;));&#10;        transferRequest.setUserId(mockTransferUser);&#10;        transferRequest.setSenderId(&quot;sender789&quot;);&#10;        transferRequest.setReceiverId(&quot;receiver789&quot;);&#10;        transferRequest.setCurrency(&quot;USD&quot;);&#10;        transferRequest.setReference(&quot;transRef&quot;);&#10;        transferRequest.setCrypto(false);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_createsAndSavesLedgerEntry() {&#10;        LedgerEntry entry = new LedgerEntry();&#10;        when(ledgerRepo.save(any())).thenReturn(entry);&#10;&#10;        LedgerEntry result = ledgerService.logDeposit(depositRequest);&#10;&#10;        assertNotNull(result);&#10;        verify(ledgerOrchestrator).recordLedgerAndTransaction(any(LedgerEntry.class));&#10;        verify(ledgerRepo, times(2)).save(any()); // once inside logTransaction, once as return&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_createsAndSavesLedgerEntry() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(1000));&#10;        LedgerEntry entry = new LedgerEntry();&#10;        when(ledgerRepo.save(any())).thenReturn(entry);&#10;&#10;        LedgerEntry result = ledgerService.logWithdrawal(withdrawalRequest);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(Status.PENDING, result.getStatus());&#10;        assertEquals(LedgerType.WITHDRAWAL, result.getType());&#10;        verify(ledgerOrchestrator).recordLedgerAndTransaction(any());&#10;        verify(ledgerRepo).save(any());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_createsTwoEntries() {&#10;        List&lt;LedgerEntry&gt; results = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(2, results.size());&#10;        verify(ledgerOrchestrator, times(2)).recordLedgerAndTransaction(any());&#10;        verify(ledgerRepo).saveAll(any());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_cryptoTransfer_hasCorrectLedgerTypes() {&#10;        transferRequest.setCrypto(true);&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_nonCryptoTransfer_hasCorrectLedgerTypes() {&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(LedgerType.TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_sameReferenceForBothEntries() {&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;        assertEquals(entries.get(0).getReference(), entries.get(1).getReference());&#10;    }&#10;&#10;    @Test&#10;    void testCreateLedgerEntryFromDeposit_setsCorrectValues() {&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setCompanyId(&quot;550e8400-e29b-41d4-a716-446655440000&quot;);&#10;        mockEntry.setSenderId(&quot;550e8400-e29b-41d4-a716-446655440098&quot;);&#10;        mockEntry.setReceiverId(&quot;550e8400-e29b-41d4-a716-446655440789&quot;);&#10;        mockEntry.setType(LedgerType.DEPOSIT);&#10;        mockEntry.setStatus(Status.SUCCESSFUL);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;&#10;        LedgerEntry entry = ledgerService.logDeposit(depositRequest);&#10;&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440000&quot;, entry.getCompanyId());&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440098&quot;, entry.getSenderId());&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440789&quot;, entry.getReceiverId());&#10;        assertEquals(LedgerType.DEPOSIT, entry.getType());&#10;        assertEquals(Status.SUCCESSFUL, entry.getStatus());&#10;    }&#10;&#10;    @Test&#10;    void testCreateLedgerEntryFromWithdrawal_setsCorrectValues() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(1000));&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setSenderId(&quot;sender456&quot;);&#10;        mockEntry.setReceiverId(&quot;receiver456&quot;);&#10;        User mockUser = new User();&#10;        mockUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440123&quot;));&#10;        mockEntry.setUserId(mockUser);&#10;        mockEntry.setCompanyId(&quot;comp456&quot;);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;&#10;        LedgerEntry entry = ledgerService.logWithdrawal(withdrawalRequest);&#10;&#10;        assertEquals(&quot;sender456&quot;, entry.getSenderId());&#10;        assertEquals(&quot;receiver456&quot;, entry.getReceiverId());&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440123&quot;, entry.getUserId().getId().toString());&#10;        assertEquals(&quot;comp456&quot;, entry.getCompanyId());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransaction_savesEntry() {&#10;        LedgerEntry dummy = LedgerEntry.builder().reference(&quot;abc&quot;).build();&#10;        when(ledgerRepo.save(any())).thenReturn(dummy);&#10;&#10;        ledgerService.logDeposit(depositRequest); // internally calls logTransaction&#10;        verify(ledgerRepo, atLeastOnce()).save(any(LedgerEntry.class));&#10;    }&#10;&#10;    @Test&#10;    void testLogTransaction_returnsNull() {&#10;        LogTransactionRequest request = new LogTransactionRequest();&#10;        LedgerEntry result = ledgerService.logTransaction(request);&#10;        assertNull(result, &quot;LogTransaction should return null for unimplemented method&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withMissingFields_stillLogs() {&#10;        DepositRequest badRequest = new DepositRequest();&#10;        badRequest.setAmount(BigDecimal.TEN);&#10;        LedgerEntry result = ledgerService.logDeposit(badRequest);&#10;        assertNull(result, &quot;Deposit with missing companyId should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogBulkDisbursement_returnsEmptyList() {&#10;        BulkDisbursementRequest bulkRequest = new BulkDisbursementRequest();&#10;        bulkRequest.setDisbursements(List.of()); // Avoid null&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logBulkDisbursement(bulkRequest);&#10;        assertNotNull(result);&#10;        assertTrue(result.isEmpty(), &quot;Bulk disbursement with no requests should return empty list&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withNullUser() {&#10;        withdrawalRequest.setUserId(null);&#10;        LedgerEntry result = ledgerService.logWithdrawal(withdrawalRequest);&#10;        assertNull(result, &quot;Withdrawal with null user should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withNullCompanyId() {&#10;        transferRequest.setCompanyId(null);&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;        assertNull(entries.get(0).getCompanyId());&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withNullAmount() {&#10;        DepositRequest badRequest = new DepositRequest();&#10;        badRequest.setAmount(null);&#10;        LedgerEntry result = ledgerService.logDeposit(badRequest);&#10;        assertNull(result, &quot;Deposit with null amount should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withInsufficientFunds() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.ZERO);&#10;        LedgerEntry result = ledgerService.logWithdrawal(withdrawalRequest);&#10;        assertNull(result, &quot;Withdrawal with insufficient funds should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withSameSenderAndReceiver() {&#10;        transferRequest.setSenderId(transferRequest.getReceiverId());&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logTransfer(transferRequest);&#10;        assertTrue(result.isEmpty(), &quot;Transfer with same sender and receiver should not process&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogBulkDisbursement_withMultipleRequests() {&#10;        BulkDisbursementRequest bulkRequest = new BulkDisbursementRequest();&#10;        TransferRequest req1 = new TransferRequest();&#10;        req1.setAmount(BigDecimal.TEN);&#10;        req1.setCompanyId(&quot;comp1&quot;);&#10;        TransferRequest req2 = new TransferRequest();&#10;        req2.setAmount(BigDecimal.TEN);&#10;        req2.setCompanyId(&quot;comp2&quot;);&#10;        bulkRequest.setDisbursements(List.of(req1, req2));&#10;&#10;        // Stub ledgerRepo.saveAll to return the input list&#10;        when(ledgerRepo.saveAll(anyList())).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logBulkDisbursement(bulkRequest);&#10;        assertNotNull(result);&#10;        assertEquals(2, result.size(), &quot;Bulk disbursement should process multiple requests&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withNegativeAmount() {&#10;        DepositRequest badRequest = new DepositRequest();&#10;        badRequest.setAmount(BigDecimal.valueOf(-100));&#10;        LedgerEntry result = ledgerService.logDeposit(badRequest);&#10;        assertNull(result, &quot;Deposit with negative amount should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withCryptoFlagTrue() {&#10;        transferRequest.setCrypto(true);&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withMissingCompanyId() {&#10;        depositRequest.setCompanyId(null);&#10;        LedgerEntry result = ledgerService.logDeposit(depositRequest);&#10;        assertNull(result, &quot;Deposit with missing companyId should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withNullRequest_throwsException() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logDeposit(null));&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withInsufficientBalance_throwsException() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(100)); &#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logWithdrawal(withdrawalRequest));&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withNullRequest_throwsException() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logTransfer(null));&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withDifferentCurrency_setsCorrectType() {&#10;        depositRequest.setCurrency(WalletCurrency.SUI);&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setType(LedgerType.DEPOSIT);&#10;        mockEntry.setStatus(Status.SUCCESSFUL);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;        LedgerEntry entry = ledgerService.logDeposit(depositRequest);&#10;        assertEquals(LedgerType.DEPOSIT, entry.getType());&#10;        assertEquals(Status.SUCCESSFUL, entry.getStatus());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_referenceIsUniqueForDifferentTransfers() {&#10;        List&lt;LedgerEntry&gt; entries1 = ledgerService.logTransfer(transferRequest);&#10;        TransferRequest anotherRequest = new TransferRequest();&#10;        anotherRequest.setAmount(BigDecimal.valueOf(3000));&#10;        anotherRequest.setCompanyId(&quot;comp999&quot;);&#10;        anotherRequest.setSenderId(&quot;sender999&quot;);&#10;        anotherRequest.setReceiverId(&quot;receiver999&quot;);&#10;        anotherRequest.setCurrency(&quot;USD&quot;);&#10;        anotherRequest.setReference(&quot;uniqueRef&quot;);&#10;        anotherRequest.setCrypto(false);&#10;        List&lt;LedgerEntry&gt; entries2 = ledgerService.logTransfer(anotherRequest);&#10;        assertNotEquals(entries1.get(0).getReference(), entries2.get(0).getReference());&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.glasswallet.Ledger.service.interfaces;&#10;&#10;import com.glasswallet.Ledger.data.model.LedgerEntry;&#10;import com.glasswallet.Ledger.data.repositories.LedgerRepo;&#10;import com.glasswallet.Ledger.dtos.requests.LogTransactionRequest;&#10;import com.glasswallet.Ledger.enums.LedgerType;&#10;import com.glasswallet.Ledger.enums.Status;&#10;import com.glasswallet.Ledger.service.implementation.LedgerServiceImpl;&#10;import com.glasswallet.Wallet.enums.WalletCurrency;&#10;import com.glasswallet.platform.data.repositories.PlatformUserRepository;&#10;import com.glasswallet.transaction.dtos.request.BulkDisbursementRequest;&#10;import com.glasswallet.transaction.dtos.request.DepositRequest;&#10;import com.glasswallet.transaction.dtos.request.TransferRequest;&#10;import com.glasswallet.transaction.dtos.request.WithdrawalRequest;&#10;import com.glasswallet.user.data.models.User;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class LedgerServiceTest {&#10;&#10;    @Mock private LedgerRepo ledgerRepo;&#10;    @Mock private LedgerOrchestrator ledgerOrchestrator;&#10;    @Mock private PlatformUserRepository userRepository;&#10;&#10;    @InjectMocks private LedgerServiceImpl ledgerService;&#10;&#10;    private DepositRequest depositRequest;&#10;    private WithdrawalRequest withdrawalRequest;&#10;    private TransferRequest transferRequest;&#10;&#10;    @BeforeEach&#10;    void setup() {&#10;        depositRequest = new DepositRequest();&#10;        depositRequest.setAmount(BigDecimal.valueOf(1000));&#10;        depositRequest.setCompanyId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440000&quot;));&#10;        depositRequest.setSenderId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440098&quot;));&#10;        depositRequest.setReceiverId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440789&quot;));&#10;        depositRequest.setCurrency(WalletCurrency.NGN);&#10;        depositRequest.setReference(&quot;ref123&quot;);&#10;&#10;        withdrawalRequest = new WithdrawalRequest();&#10;        withdrawalRequest.setAmount(BigDecimal.valueOf(500));&#10;        withdrawalRequest.setCompanyId(&quot;comp456&quot;);&#10;        User mockUser = new User();&#10;        mockUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440123&quot;));&#10;        withdrawalRequest.setSenderId(String.valueOf(mockUser));&#10;        withdrawalRequest.setSenderId(&quot;sender456&quot;);&#10;        withdrawalRequest.setReceiverId(&quot;receiver456&quot;);&#10;        withdrawalRequest.setCurrency(&quot;USD&quot;);&#10;        withdrawalRequest.setReference(&quot;withdrawRef&quot;);&#10;&#10;        transferRequest = new TransferRequest();&#10;        transferRequest.setAmount(BigDecimal.valueOf(2000));&#10;        transferRequest.setCompanyId(&quot;comp789&quot;);&#10;        User mockTransferUser = new User();&#10;        mockTransferUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440124&quot;));&#10;        transferRequest.setUserId(mockTransferUser);&#10;        transferRequest.setSenderId(&quot;sender789&quot;);&#10;        transferRequest.setReceiverId(&quot;receiver789&quot;);&#10;        transferRequest.setCurrency(&quot;USD&quot;);&#10;        transferRequest.setReference(&quot;transRef&quot;);&#10;        transferRequest.setCrypto(false);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_createsAndSavesLedgerEntry() {&#10;        LedgerEntry entry = new LedgerEntry();&#10;        when(ledgerRepo.save(any())).thenReturn(entry);&#10;&#10;        LedgerEntry result = ledgerService.logDeposit(depositRequest);&#10;&#10;        assertNotNull(result);&#10;        verify(ledgerOrchestrator).recordLedgerAndTransaction(any(LedgerEntry.class));&#10;        verify(ledgerRepo, times(2)).save(any()); // once inside logTransaction, once as return&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_createsAndSavesLedgerEntry() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(1000));&#10;        LedgerEntry entry = new LedgerEntry();&#10;        when(ledgerRepo.save(any())).thenReturn(entry);&#10;&#10;        LedgerEntry result = ledgerService.logWithdrawal(withdrawalRequest, &quot;txid123&quot;, &quot;platformId123&quot;, &quot;platformUserId123&quot;);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(Status.PENDING, result.getStatus());&#10;        assertEquals(LedgerType.WITHDRAWAL, result.getType());&#10;        verify(ledgerOrchestrator).recordLedgerAndTransaction(any());&#10;        verify(ledgerRepo).save(any());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_createsTwoEntries() {&#10;        List&lt;LedgerEntry&gt; results = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(2, results.size());&#10;        verify(ledgerOrchestrator, times(2)).recordLedgerAndTransaction(any());&#10;        verify(ledgerRepo).saveAll(any());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_cryptoTransfer_hasCorrectLedgerTypes() {&#10;        transferRequest.setCrypto(true);&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_nonCryptoTransfer_hasCorrectLedgerTypes() {&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;&#10;        assertEquals(LedgerType.TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_sameReferenceForBothEntries() {&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;        assertEquals(entries.get(0).getReference(), entries.get(1).getReference());&#10;    }&#10;&#10;    @Test&#10;    void testCreateLedgerEntryFromDeposit_setsCorrectValues() {&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setCompanyId(&quot;550e8400-e29b-41d4-a716-446655440000&quot;);&#10;        mockEntry.setSenderId(&quot;550e8400-e29b-41d4-a716-446655440098&quot;);&#10;        mockEntry.setReceiverId(&quot;550e8400-e29b-41d4-a716-446655440789&quot;);&#10;        mockEntry.setType(LedgerType.DEPOSIT);&#10;        mockEntry.setStatus(Status.SUCCESSFUL);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;&#10;        LedgerEntry entry = ledgerService.logDeposit(depositRequest);&#10;&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440000&quot;, entry.getCompanyId());&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440098&quot;, entry.getSenderId());&#10;        assertEquals(&quot;550e8400-e29b-41d4-a716-446655440789&quot;, entry.getReceiverId());&#10;        assertEquals(LedgerType.DEPOSIT, entry.getType());&#10;        assertEquals(Status.SUCCESSFUL, entry.getStatus());&#10;    }&#10;&#10;    @Test&#10;    void testCreateLedgerEntryFromWithdrawal_setsCorrectValues() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(1000));&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setSenderId(&quot;sender456&quot;);&#10;        mockEntry.setReceiverId(&quot;receiver456&quot;);&#10;        User mockUser = new User();&#10;        mockUser.setId(UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440123&quot;));&#10;        mockEntry.setCompanyId(&quot;comp456&quot;);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;&#10;        LedgerEntry entry = ledgerService.logWithdrawal(withdrawalRequest, &quot;txid123&quot;, &quot;platformId123&quot;, &quot;platformUserId123&quot;);&#10;&#10;        assertEquals(&quot;sender456&quot;, entry.getSenderId());&#10;        assertEquals(&quot;receiver456&quot;, entry.getReceiverId());&#10;        assertEquals(&quot;comp456&quot;, entry.getCompanyId());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransaction_savesEntry() {&#10;        LedgerEntry dummy = LedgerEntry.builder().reference(&quot;abc&quot;).build();&#10;        when(ledgerRepo.save(any())).thenReturn(dummy);&#10;&#10;        ledgerService.logDeposit(depositRequest); // internally calls logTransaction&#10;        verify(ledgerRepo, atLeastOnce()).save(any(LedgerEntry.class));&#10;    }&#10;&#10;    @Test&#10;    void testLogTransaction_returnsNull() {&#10;        LogTransactionRequest request = new LogTransactionRequest();&#10;        LedgerEntry result = ledgerService.logTransaction(request);&#10;        assertNull(result, &quot;LogTransaction should return null for unimplemented method&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withMissingFields_stillLogs() {&#10;        DepositRequest badRequest = new DepositRequest();&#10;        badRequest.setAmount(BigDecimal.TEN);&#10;        LedgerEntry result = ledgerService.logDeposit(badRequest);&#10;        assertNull(result, &quot;Deposit with missing companyId should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogBulkDisbursement_returnsEmptyList() {&#10;        BulkDisbursementRequest bulkRequest = new BulkDisbursementRequest();&#10;        bulkRequest.setDisbursements(List.of()); // Avoid null&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logBulkDisbursement(bulkRequest);&#10;        assertNotNull(result);&#10;        assertTrue(result.isEmpty(), &quot;Bulk disbursement with no requests should return empty list&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withNullUser() {&#10;        // WithdrawalRequest does not have setUserId, so this test is not applicable. Remove or skip.&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withInsufficientFunds() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.ZERO);&#10;        LedgerEntry result = ledgerService.logWithdrawal(withdrawalRequest, &quot;txid123&quot;, &quot;platformId123&quot;, &quot;platformUserId123&quot;);&#10;        assertNull(result, &quot;Withdrawal with insufficient funds should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withSameSenderAndReceiver() {&#10;        transferRequest.setSenderId(transferRequest.getReceiverId());&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logTransfer(transferRequest);&#10;        assertTrue(result.isEmpty(), &quot;Transfer with same sender and receiver should not process&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogBulkDisbursement_withMultipleRequests() {&#10;        BulkDisbursementRequest bulkRequest = new BulkDisbursementRequest();&#10;        TransferRequest req1 = new TransferRequest();&#10;        req1.setAmount(BigDecimal.TEN);&#10;        req1.setCompanyId(&quot;comp1&quot;);&#10;        TransferRequest req2 = new TransferRequest();&#10;        req2.setAmount(BigDecimal.TEN);&#10;        req2.setCompanyId(&quot;comp2&quot;);&#10;        bulkRequest.setDisbursements(List.of(req1, req2));&#10;&#10;        // Stub ledgerRepo.saveAll to return the input list&#10;        when(ledgerRepo.saveAll(anyList())).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;&#10;        List&lt;LedgerEntry&gt; result = ledgerService.logBulkDisbursement(bulkRequest);&#10;        assertNotNull(result);&#10;        assertEquals(2, result.size(), &quot;Bulk disbursement should process multiple requests&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withNegativeAmount() {&#10;        DepositRequest badRequest = new DepositRequest();&#10;        badRequest.setAmount(BigDecimal.valueOf(-100));&#10;        LedgerEntry result = ledgerService.logDeposit(badRequest);&#10;        assertNull(result, &quot;Deposit with negative amount should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withCryptoFlagTrue() {&#10;        transferRequest.setCrypto(true);&#10;        List&lt;LedgerEntry&gt; entries = ledgerService.logTransfer(transferRequest);&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_OUT, entries.get(0).getType());&#10;        assertEquals(LedgerType.CRYPTO_TRANSFER_IN, entries.get(1).getType());&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withMissingCompanyId() {&#10;        depositRequest.setCompanyId(null);&#10;        LedgerEntry result = ledgerService.logDeposit(depositRequest);&#10;        assertNull(result, &quot;Deposit with missing companyId should return null&quot;);&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withNullRequest_throwsException() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logDeposit(null));&#10;    }&#10;&#10;    @Test&#10;    void testLogWithdrawal_withInsufficientBalance_throwsException() {&#10;        when(userRepository.getBalance(any())).thenReturn(BigDecimal.valueOf(100)); &#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logWithdrawal(withdrawalRequest, &quot;txid123&quot;, &quot;platformId123&quot;, &quot;platformUserId123&quot;));&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_withNullRequest_throwsException() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; ledgerService.logTransfer(null));&#10;    }&#10;&#10;    @Test&#10;    void testLogDeposit_withDifferentCurrency_setsCorrectType() {&#10;        depositRequest.setCurrency(WalletCurrency.SUI);&#10;        LedgerEntry mockEntry = new LedgerEntry();&#10;        mockEntry.setType(LedgerType.DEPOSIT);&#10;        mockEntry.setStatus(Status.SUCCESSFUL);&#10;        when(ledgerRepo.save(any())).thenReturn(mockEntry);&#10;        LedgerEntry entry = ledgerService.logDeposit(depositRequest);&#10;        assertEquals(LedgerType.DEPOSIT, entry.getType());&#10;        assertEquals(Status.SUCCESSFUL, entry.getStatus());&#10;    }&#10;&#10;    @Test&#10;    void testLogTransfer_referenceIsUniqueForDifferentTransfers() {&#10;        List&lt;LedgerEntry&gt; entries1 = ledgerService.logTransfer(transferRequest);&#10;        TransferRequest anotherRequest = new TransferRequest();&#10;        anotherRequest.setAmount(BigDecimal.valueOf(3000));&#10;        anotherRequest.setCompanyId(&quot;comp999&quot;);&#10;        anotherRequest.setSenderId(&quot;sender999&quot;);&#10;        anotherRequest.setReceiverId(&quot;receiver999&quot;);&#10;        anotherRequest.setCurrency(&quot;USD&quot;);&#10;        anotherRequest.setReference(&quot;uniqueRef&quot;);&#10;        anotherRequest.setCrypto(false);&#10;        List&lt;LedgerEntry&gt; entries2 = ledgerService.logTransfer(anotherRequest);&#10;        assertNotEquals(entries1.get(0).getReference(), entries2.get(0).getReference());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>